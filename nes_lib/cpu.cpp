// cpu.cpp contains the code to successfully emulate the 6502 that was inside the NES
// YAY FOR THIS BEING FUN!
#include "cpu.h"
#include <iostream>

NesCpu::NesCpu(NesMemory * memory) {
    this -> RAM = memory;
}

NesCpu::~NesCpu() {

}

void NesCpu::power_up() {
    this->registers.P = 0x34;
    this->registers.A = 0x00;
    this->registers.X = 0x00;
    this->registers.Y = 0x00;
    this->registers.S = 0xFD;
}

uint16_t NesCpu::getAddrBasedOnMode(AddressingMode mode) {
    //TODO: Return the Proper Address based on PC and increment Program Counter so that it at the proper spot
    uint16_t finaladdr = 0;
    switch (mode) {
        case ADDR_MODE_IMPLICIT: {
            finaladdr = 0;
            break;
        }
        case ADDR_MODE_ACCUMULATOR: {
            finaladdr = 0;
            break;
        }
        case ADDR_MODE_IMMEDIATE: {
            finaladdr = uint16_t(this->registers.PC++);
            break;
        }
        case ADDR_MODE_ZP: {
            finaladdr = this->RAM->read_byte(this->registers.PC++);
            break;
        }
        case ADDR_MODE_ZPX: {
            finaladdr = ((this->RAM->read_byte(this->registers.PC++)) + this->registers.X);
            break;
        }
        case ADDR_MODE_ZPY: {
            finaladdr = ((this->RAM->read_byte(this->registers.PC++)) + this->registers.Y);
            break;
        }
        case ADDR_MODE_RELATIVE: {
            uint8_t offset = this->RAM->read_byte(this->registers.PC++);
            finaladdr = this->registers.PC;
            finaladdr += offset;
            break;
        }
        case ADDR_MODE_ABSOLUTE: {
            finaladdr = this->RAM->read_word(this->registers.PC);
            this->registers.PC += 2;
            break;
        }
        case ADDR_MODE_ABSOLUTEX: {
            finaladdr = this->RAM->read_word(this->registers.PC);
            this->registers.PC += 2;
            finaladdr += this->registers.X;
            break;
        }
        case ADDR_MODE_ABSOLUTEY: {
            finaladdr = this->RAM->read_word(this->registers.PC);
            this->registers.PC += 2;
            finaladdr += this->registers.Y;
            break;
        }
        case ADDR_MODE_INDIRECT: {
            uint16_t tempaddress = this->RAM->read_word(this->registers.PC);
            this->registers.PC += 2;
            finaladdr = this->RAM->read_word(tempaddress);
            break;
        }
        case ADDR_MODE_INDIRECTX: {
            uint8_t tempaddress = this->RAM->read_byte(this->registers.PC++);
            tempaddress += this->registers.X;
            finaladdr = this->RAM->read_word(tempaddress);
            break;
        }
        case ADDR_MODE_INDIRECTY: {
            uint8_t tempaddress = this->RAM->read_byte(this->registers.PC++);
            finaladdr = this->RAM->read_word(tempaddress);
            finaladdr += this->registers.Y;
            break;
        }
        default: {
            finaladdr = 0;
            break;
        }
    }
    return finaladdr;
}


void NesCpu::step() {
    // TODO: Implement Interrupts

    //Fetch Op Code
    uint8_t opcode = this->RAM->read_byte(this->registers.PC++);
    const Instruction *currentInstruction = &this->instructions[opcode];

    if (currentInstruction -> addrMode == INVALID_OPCODE) {
        std::cerr << "Invalid OpCode Used" << currentInstruction -> name << std::endl;
        return;
    }

    uint16_t address = getAddrBasedOnMode(currentInstruction -> addrMode);

    currentInstruction -> instFunc(address, this);

}

void NesCpu::pushStackBtye(uint8_t data) {
    uint16_t address = uint16_t(STACK_BASE) + this->registers.S;
    this->RAM->write_byte(address, data);
    this->registers.S--;
}

uint8_t NesCpu::popStackByte() {
    this->registers.S++;
    uint8_t data = this->RAM->read_byte(uint16_t(STACK_BASE) + this->registers.S);
    return data;
}

void NesCpu::pushStackWord(uint16_t data) {
    uint16_t address = uint16_t(STACK_BASE) + this->registers.S;
    this->RAM->stack_write_word(address, data);
    this->registers.S-=2;
}

uint16_t NesCpu::popStackWord() {
    this->registers.S++;
    uint16_t data = this->RAM->read_word(uint16_t(STACK_BASE) +this->registers.S);
    this->registers.S++;
    return data;
}

void NesCpu::setFlags(uint8_t mask, bool set) {
    if (set) {
        this->registers.P |= mask;
    }
    else {
        this->registers.P &= ~mask;
    }
}

void NesCpu::NMI() {
    this->pushStackWord(this->registers.PC);
    uint8_t flags = this->registers.P;
    // Clear B Flag when generated by Interrupt
    flags &= ~B_MASK;
    this->pushStackBtye(flags);

    this->registers.PC = this->RAM->read_word(NMI_INTERRUPT_VECTOR);
    //Per NESDev Wiki http://wiki.nesdev.com/w/index.php/CPU_ALL
    this->setFlags(INTERRUPT_DISABLE_MASK, true);
}

void NesCpu::IRQ() {
    this->pushStackWord(this->registers.PC);
    uint8_t flags = this->registers.P;
    // Clear B flag when generated by Interrupt
    flags &= ~B_MASK;
    this->pushStackBtye(flags);

    this->registers.PC = this->RAM->read_word(IRQ_INTERRUPT_VECTOR);
    //Per NESDev Wiki http://wiki.nesdev.com/w/index.php/CPU_ALL
    this->setFlags(INTERRUPT_DISABLE_MASK, true);
}

void NesCpu::updateZeroFlag(uint8_t value) {
    bool set = (value == 0);
    this->setFlags(ZERO_MASK, set);
}

void NesCpu::updateNegativeFlag(uint8_t value) {
    bool set = ((value&0x80) == 0x80);
    this->setFlags(NEGATIVE_MASK, set);
}

void NesCpu::performBranch(uint16_t address) {
    // TODO: Do some page cross checking for timing
    this->registers.PC = address;
}


void brk(uint16_t address, NesCpu * cpu) {
    cpu->pushStackWord(cpu->registers.PC);
    uint8_t flags = cpu->registers.P;
    // Set B Flag when generated by Program
    flags |= B_MASK;
    cpu->pushStackBtye(flags);

    cpu->registers.PC = cpu->RAM->read_word(IRQ_INTERRUPT_VECTOR);
    //Per NESDev Wiki http://wiki.nesdev.com/w/index.php/CPU_ALL
    cpu->setFlags(INTERRUPT_DISABLE_MASK, true);
}

void ora(uint16_t address, NesCpu * cpu) {
    uint8_t value = cpu->RAM->read_byte(address);

    cpu->registers.A |= value;
    cpu->updateZeroFlag(cpu->registers.A);
    cpu->updateNegativeFlag(cpu->registers.A);
}

void slo(uint16_t address, NesCpu * cpu) {
    //TODO: Illegal Opcode Lookup and Implement
}

void dop(uint16_t address, NesCpu * cpu) {
    //NOOP
}

void asl(uint16_t address, NesCpu * cpu) {
    uint8_t value = cpu->RAM->read_byte(address);
    bool set = ((value&0x80) == 0x80);
    cpu->setFlags(CARRY_MASK, set);
    value <<= 1;

    cpu->updateZeroFlag(value);
    cpu->updateNegativeFlag(value);

    cpu->RAM->write_byte(address, value);
}

void asla(uint16_t address, NesCpu * cpu) {
    uint8_t value = cpu->registers.A;
    bool set = ((cpu->registers.A&0x80) == 0x80);
    cpu->setFlags(CARRY_MASK, set);
    cpu->registers.A <<= 1;

    cpu->updateZeroFlag(cpu->registers.A);
    cpu->updateNegativeFlag(cpu->registers.A);
}

void php(uint16_t address, NesCpu * cpu) {
    // B Flag Needs to be set per NESDev Wiki
    cpu->pushStackBtye((cpu->registers.P | uint8_t(B_MASK)));
}

void anc(uint16_t address, NesCpu * cpu) {
    //TODO: Illegal Opcode Lookup and Implement
}

void top(uint16_t address, NesCpu * cpu) {
    //NOOP
}

void bpl(uint16_t address, NesCpu * cpu) {
    if (TEST_NEGATIVE(cpu->registers.P)) {
        cpu->performBranch(address);
    }
}

